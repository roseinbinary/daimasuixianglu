## 🧩 LeetCode 刷题日记  
**日期：** 2025/10/20  
**主题：** 第五章 栈与队列 Part 02｜表达式求值 · 单调队列 · 优先级队列  
**题目：**  
- [150. Evaluate Reverse Polish Notation（栈应用 · 表达式求值）](https://leetcode.com/problems/evaluate-reverse-polish-notation/)  
- [239. Sliding Window Maximum（单调队列 · 窗口维护）](https://leetcode.com/problems/sliding-window-maximum/)  
- [347. Top K Frequent Elements（堆 / 优先队列 · 高频统计）](https://leetcode.com/problems/top-k-frequent-elements/)  

**今日状态：**  
三道题都较有挑战性，分别代表了“栈”、“队列”、“堆”的高级应用场景。

---

### 🧠 解题思路总结

#### 150. Evaluate Reverse Polish Notation（栈应用 · 表达式求值）
- **题目要点：**  
  根据后缀表达式（逆波兰表达式）计算值。  
  运算符位于两个操作数之后，例如：`["2", "1", "+", "3", "*"] = (2 + 1) * 3 = 9`。  
- **核心思路：**
  - 遍历 tokens：  
    - 若为数字 → 压入栈。  
    - 若为运算符 → 弹出两个数字，计算结果再压入栈。  
  - 最终栈顶即结果。  
- **实现细节：**
  - 注意出栈顺序：第二次出栈为左操作数。  
  - Python 中除法结果需用 `int()` 截断以匹配题意（向零取整）。  
- **复杂度：** O(n)。  
- **代码示例：**
  ```python
  stack = []
  for token in tokens:
      if token not in "+-*/":
          stack.append(int(token))
      else:
          b, a = stack.pop(), stack.pop()
          if token == '+': stack.append(a + b)
          elif token == '-': stack.append(a - b)
          elif token == '*': stack.append(a * b)
          else: stack.append(int(a / b))
  return stack[0]
  ```

📎 讲解链接：[150. 逆波兰表达式求值](https://programmercarl.com/0150.%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC.html)

---

#### 239. Sliding Window Maximum（单调队列 · 窗口维护）
- **题目要点：**  
  给定数组 `nums` 和滑动窗口大小 `k`，输出每个窗口的最大值。  
- **核心思路：**
  - 维护一个 **单调递减队列（deque）** 存储下标：  
    - 队首永远是当前窗口最大值的下标；  
    - 每次入队前，移除所有小于当前值的元素（保持递减）；  
    - 移除超出窗口范围的元素（索引差 >= k）。  
- **示意：**
  ```
  输入: [1,3,-1,-3,5,3,6,7], k = 3
  输出: [3,3,5,5,6,7]
  ```
- **复杂度：** O(n)（每个元素最多进出队一次）。  
- **常见错误：**  
  - 队列中存的是 **下标** 不是值；  
  - 忘记在滑动时移除过期下标。  

📎 讲解链接：[239. 滑动窗口最大值](https://programmercarl.com/0239.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC.html)

---

#### 347. Top K Frequent Elements（堆 / 优先队列 · 高频统计）
- **题目要点：**  
  找出出现频率最高的前 K 个元素。  
- **核心思路：**
  1. 用 `HashMap` 统计每个元素出现次数。  
  2. 用 **最小堆（min-heap）** 保存前 K 个元素：  
     - 若堆大小 < K：直接入堆；  
     - 否则比较当前频次与堆顶最小频次，若更大则替换。  
  3. 输出堆中元素即结果。  
- **复杂度：** O(n log k)。  
- **Python 实现：**
  ```python
  import heapq
  count = Counter(nums)
  heap = []
  for num, freq in count.items():
      heapq.heappush(heap, (freq, num))
      if len(heap) > k:
          heapq.heappop(heap)
  return [num for (freq, num) in heap]
  ```
- **延伸应用：**  
  高频统计、日志分析、推荐系统、Top-K 问题等。  

📎 讲解链接：[347. 前 K 个高频元素](https://programmercarl.com/0347.%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0.html)

---

### ⚡ 易错点 / 卡壳点
- 150 题：操作数出栈顺序错误会导致减法/除法出错。  
- 239 题：队列中存下标，维护单调递减性质；滑动时需判断元素是否出窗口。  
- 347 题：混淆最小堆与最大堆（Python 默认是最小堆）。  

---

### ✅ 改进方案
- 对“栈 / 队列 / 堆”的区别进行总结：  
  | 数据结构 | 特性 | 常见用途 |
  |-----------|--------|-----------|
  | 栈 | 后进先出 LIFO | 表达式求值、括号匹配、回溯 |
  | 队列 | 先进先出 FIFO | 滑动窗口、BFS、缓存系统 |
  | 堆 | 局部有序 | Top-K、高频统计、优先任务调度 |
- 多画图理解单调队列维护的过程。  
- 手动实现 `heapq` 的 push-pop 操作，理解优先队列机制。  

---

### 💬 一句话总结
栈、队列、堆是“算法的发动机”三件套：  
**栈处理顺序问题，队列维护窗口状态，堆解决优先级调度。**  
理解它们的特性，就是掌握算法优化的第一步。

---

📘 延伸阅读：  
👉 [栈与队列章节总结](https://programmercarl.com/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E6%80%BB%E7%BB%93.html)
