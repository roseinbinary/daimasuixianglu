## 🧩 LeetCode 刷题日记  
**日期：** 2025/10/26  
**主题：** 动态规划 Part 02｜二维 DP · 网格路径 · 障碍物处理  
**题目：**  
- [62. Unique Paths（二维 DP · 基本网格路径）](https://leetcode.com/problems/unique-paths/)  
- [63. Unique Paths II（二维 DP + 障碍物）](https://leetcode.com/problems/unique-paths-ii/)  
- （343, 96 暂缓一刷）

---

## 🌱 今日 DP 核心思路总结  
本章是典型的**网格类二维动态规划**。  
你已经掌握了关键的三要素：

1. **dp[i][j] 的定义必须非常明确**
2. **状态由“来源”决定：上方与左方**
3. **初始化决定第一行、第一列的正确性**
4. **遍历顺序必须左→右，上→下，让前序状态已计算完毕**

---

## 💡 62. Unique Paths（二维 DP · 不同路径）

### 🧩 状态定义
`dp[i][j]` = 从起点 (0,0) 到 (i,j) 的不同路径数量。

### 🔁 状态转移方程
**只能从上或左走到当前位置：**
```
dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
```

### 🟦 初始化
- 第一列只能向下走 → 都为 1  
- 第一行只能向右走 → 都为 1  
```
dp[i][0] = 1  
dp[0][j] = 1
```

### 🔄 遍历顺序
✔ 必须从左到右，从上到下（保证依赖项已计算）。

### ⭐ 核心理解
- dp 的定义决定你只需要关注“到达方式”。
- 这是最标准、最纯净的二维 DP 模板题。

---

## 💡 63. Unique Paths II（二维 DP · 含障碍物）

比 62 难点在于加入了“障碍物”，即 `grid[i][j] = 1`。

### 🧩 状态定义
仍然是 `dp[i][j] = 从起点到这里的路径数`。

### 🔁 状态转移方程  
和 62 完全相同，但要加上「障碍物剪枝」：
```
if grid[i][j] == 1:
    dp[i][j] = 0  # 障碍物位置永远不可达
else:
    dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
```

### 🟦 初始化（本题最大难点）
第一行、第一列必须小心处理：

- 若在第一行 or 第一列出现障碍，则**该障碍之后的所有格子都不可达**：
```
(0,0) → 1 → 1 → X → X → X
```
第二个 `1` 若是障碍，后面都必须保持 0。

你已经理解到位了，这个细节是 63 的关键！

### 🔄 遍历顺序
依旧从左→右，上→下。

---

## 🚧 343、96 暂缓一刷  
这两题属于“完全背包 + 卡特兰数”的难度，放到后续 DP 高级阶段更合理。  
你先跳过完全没问题。

---

## ⚡ 易错点 / 卡点
- 62、63 的 dp 初始化若写错会影响整张表的计算；  
- 63 中若忽略障碍后的单行/单列状态，会出现“绕过障碍”的错误结果；  
- 必须保证转移方向一致：左→右、上→下。

---

## ✅ 改进方案
- 练习从“状态定义”出发推导转移，而不是背公式；  
- 多画 3×3、4×4 小表格模拟 dp 填充过程；  
- 下次练习可以尝试将 dp[][] 压缩成一维 dp（滚动数组优化）。

---

## 💬 一句话总结
二维网格 DP 的精髓是——  
**每个格子的值 = 来自上方 + 来自左方**。  
障碍物只是把某些格子变成「永远不可达」，  
其余逻辑完全一致。

