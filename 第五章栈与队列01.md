## 🧩 LeetCode 刷题日记  
**日期：** 2025/10/18
**主题：** 第五章 栈与队列 · 基础原理与经典应用  
**题目：**  
- [232. Implement Queue using Stacks（双栈模拟队列）](https://leetcode.com/problems/implement-queue-using-stacks/)  
- [225. Implement Stack using Queues（单队列模拟栈）](https://leetcode.com/problems/implement-stack-using-queues/)  
- [20. Valid Parentheses（栈应用 · 括号匹配）](https://leetcode.com/problems/valid-parentheses/)  
- [1047. Remove All Adjacent Duplicates In String（栈应用 · 消除重复项）](https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string/)  

---

### 🧠 理论基础：栈与队列机制

📚 **栈（Stack）**：  
- 特点：**后进先出（LIFO）**。  
- 常见实现方式：数组 / 链表。  
- 常用操作：`push(x)`、`pop()`、`top()`、`empty()`。  
- 应用场景：递归、括号匹配、字符串消除、表达式求值。

📘 **队列（Queue）**：  
- 特点：**先进先出（FIFO）**。  
- 常见实现方式：双指针数组 / 链表 / 双端队列（deque）。  
- 常用操作：`push(x)`、`pop()`、`front()`、`empty()`。  
- 应用场景：广度优先搜索（BFS）、任务调度、缓存系统。

📎 讲解文章：[栈与队列理论基础](https://programmercarl.com/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html)

---

### 💡 232. 用栈实现队列（双栈模拟队列）
- **原理：** 用两个栈 `inStack` 和 `outStack` 模拟先进先出。  
- **核心思想：**  
  - 入队时压入 `inStack`。  
  - 出队时若 `outStack` 为空，则把 `inStack` 全部弹出压入 `outStack`，再弹出顶部。  
  - 这样保证顺序反转一次后，出栈顺序即为队列顺序。  
- **复杂度分析：**  
  - 均摊时间复杂度：O(1)。  
  - 每个元素最多进出两个栈各一次。

📎 详细讲解：[232. 用栈实现队列](https://programmercarl.com/0232.%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97.html)

---

### 💡 225. 用队列实现栈（单队列模拟栈）
- **思路一（传统）：** 用两个队列轮换实现。  
- **思路二（推荐）：** 只用一个队列，关键在于**每次入队后将前面的元素依次出队再入队**，使新元素排在队首。  
- **示例：**
  ```python
  def push(x):
      q.append(x)
      for _ in range(len(q) - 1):
          q.append(q.pop(0))
  ```
- **复杂度分析：**
  - 入栈 O(n)，出栈 O(1)。  
  - 空间 O(n)。  

📎 详细讲解：[225. 用队列实现栈](https://programmercarl.com/0225.%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88.html)

---

### 💡 20. 有效的括号（栈应用 · 括号匹配）
- **核心思路：** 遇到左括号入栈，遇到右括号时匹配栈顶是否为对应类型。  
- **匹配规则：**
  - 若匹配成功则弹栈；
  - 若不匹配或栈空则返回 False；
  - 遍历结束栈空即有效。  
- **常见陷阱：**  
  - 忘记检查栈空状态；
  - 字符串遍历完后栈非空仍需返回 False。  
- **应用延伸：** HTML 标签配对、表达式求值等。

📎 详细讲解：[20. 有效的括号](https://programmercarl.com/0020.%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7.html)

---

### 💡 1047. 删除字符串中的所有相邻重复项（栈应用 · 消除重复）
- **核心思想：** 栈天然适合做“相邻判断 + 撤销操作”。  
- **思路：**
  - 遍历字符串；
  - 若当前字符与栈顶相同 → 弹栈（表示抵消）；
  - 否则入栈；
  - 最终栈中剩余字符即为结果。  
- **示例：**
  ```python
  stack = []
  for ch in s:
      if stack and stack[-1] == ch:
          stack.pop()
      else:
          stack.append(ch)
  return ''.join(stack)
  ```
- **时间复杂度：** O(n)，每个元素最多进出栈一次。

📎 详细讲解：[1047. 删除字符串中的所有相邻重复项](https://programmercarl.com/1047.%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9.html)

---

### ⚡ 易错点 / 卡壳点
- 232 题中若不在 `outStack` 为空时再转移，会导致顺序错误。  
- 225 题若忘记在入栈后旋转队列，会变成普通队列行为。  
- 20 题需确保遍历结束后栈为空才返回 True。  
- 1047 题注意“相邻”含义，仅删除连续的相同字符。  

---

### ✅ 改进方案
- 理解“栈与队列是相反的操作机制”：栈反向输出，队列正向输出。  
- 掌握两个模拟模式：  
  1. **用栈实现队列**（反转顺序）  
  2. **用队列实现栈**（旋转顺序）  
- 练习用图理解两种数据结构的入/出方向关系。  
- 栈的常见应用模板：
  - 括号匹配；
  - 消除重复；
  - 单调栈（下章会深入）。  

---

### 💬 一句话总结
栈与队列看似简单，却是构建许多高级算法的基石。  
它们的本质区别只在于**元素出入的方向**，  
而这点细微差别，决定了它们在算法设计中的巨大用途。
